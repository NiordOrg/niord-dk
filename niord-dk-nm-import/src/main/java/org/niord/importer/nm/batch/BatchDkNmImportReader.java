/*
 * Copyright 2016 Danish Maritime Authority.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.niord.importer.nm.batch;

import org.niord.core.NiordApp;
import org.niord.core.geojson.GeometryFormatService;
import org.niord.core.message.Message;
import org.niord.core.message.MessagePart;
import org.niord.core.message.MessagePartDesc;
import org.niord.core.message.batch.BatchMessageImportReader;
import org.niord.core.message.vo.SystemMessageVo;
import org.niord.importer.nm.extract.NmHtmlExtractor;
import org.niord.model.DataFilter;
import org.niord.model.geojson.FeatureCollectionVo;
import org.niord.model.message.MessagePartType;

import javax.inject.Inject;
import javax.inject.Named;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import static org.niord.model.message.MessagePartType.*;

/**
 * Imports a list of legacy NM messages from HTML file generated by saving an NM Word document as HTML.
 * <p>
 * Please note, the actual dk-nm-import.xml job file is not placed in the META-INF/batch-jobs of this project,
 * but rather, in the META-INF/batch-jobs folder of the niord-web project.<br>
 * This is because of a class-loading bug in the Wildfly implementation. See e.g.
 * https://issues.jboss.org/browse/WFLY-4988
 */
@Named
public class BatchDkNmImportReader extends BatchMessageImportReader {

    @Inject
    GeometryFormatService geometryFormatService;

    @Inject
    NiordApp app;

    /** Reads in the batch import messages */
    @Override
    protected List<SystemMessageVo> readMessages() throws Exception {
        // Extract messages from the HTML
        Path path = batchService.getBatchJobDataFile(jobContext.getInstanceId());
        NmHtmlExtractor extractor = new NmHtmlExtractor(path.toFile());

        getLog().info("Parsing NMs for year " + extractor.getYear() +  ", week " + extractor.getWeek());
        List<Message> messages = extractor.extractNms();

        DataFilter dataFilter = DataFilter.get()
                .fields(DataFilter.DETAILS, DataFilter.GEOMETRY, "Area.parent");

        return messages.stream()
                .map(this::updateMessageParts)
                .map(m -> m.toVo(SystemMessageVo.class, dataFilter))
                .collect(Collectors.toList());
    }


    /**
     * Updates the message parts of the message
     * @param message the message to update
     * @return the updated message
     */
    private Message updateMessageParts(Message message) {

        // Add a "Positions" message part if the "Details" message part has an associated geometry
        MessagePart posPart = new MessagePart(POSITIONS);
        message.partsByType(MessagePartType.DETAILS).stream()
                .filter(p -> p.getGeometry() != null && !p.getGeometry().getFeatures().isEmpty())
                .forEach(p -> Arrays.stream(app.getLanguages())
                        .forEach(lang -> {
                            MessagePartDesc desc = posPart.checkCreateDesc(lang);
                            FeatureCollectionVo geometry = p.getGeometry().toGeoJson();
                            desc.setDetails(geometryFormatService.appendGeometryToDetails(
                                    lang,
                                    desc.getDetails(),
                                    geometry));
                        }));
        if (posPart.partDefined()) {
            message.addPart(posPart);
        }

        // Sort the message parts according to the order use in legacy EfS
        List<MessagePartType> typeOrder = Arrays.asList(TIME, POSITIONS, DETAILS, PROHIBITION, SIGNALS, NOTE);
        message.getParts().sort((p1, p2) -> typeOrder.indexOf(p1.getType()) - typeOrder.indexOf(p2.getType()));

        return message;
    }

}
