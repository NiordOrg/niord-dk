/*
 * Copyright 2016 Danish Maritime Authority.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.niord.importer.nm.batch;

import org.niord.core.NiordApp;
import org.niord.core.area.Area;
import org.niord.core.area.AreaService;
import org.niord.core.geojson.GeometryFormatService;
import org.niord.core.message.Message;
import org.niord.core.message.MessagePart;
import org.niord.core.message.MessagePartDesc;
import org.niord.core.message.batch.BatchMessageImportReader;
import org.niord.core.message.vo.SystemMessageVo;
import org.niord.core.model.DescEntity;
import org.niord.importer.nm.extract.NmHtmlExtractor;
import org.niord.model.DataFilter;
import org.niord.model.geojson.FeatureCollectionVo;
import org.niord.model.message.MessagePartType;

import javax.inject.Inject;
import javax.inject.Named;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import static org.niord.model.message.MessagePartType.*;

/**
 * Imports a list of legacy NM messages from HTML file generated by saving an NM Word document as HTML.
 * <p>
 * Please note, the actual dk-nm-import.xml job file is not placed in the META-INF/batch-jobs of this project,
 * but rather, in the META-INF/batch-jobs folder of the niord-web project.<br>
 * This is because of a class-loading bug in the Wildfly implementation. See e.g.
 * https://issues.jboss.org/browse/WFLY-4988
 */
@Named
public class BatchDkNmImportReader extends BatchMessageImportReader {

    @Inject
    GeometryFormatService geometryFormatService;

    @Inject
    AreaService areaService;

    @Inject
    NiordApp app;

    /** Reads in the batch import messages */
    @Override
    protected List<SystemMessageVo> readMessages() throws Exception {
        // Extract messages from the HTML
        Path path = batchService.getBatchJobDataFile(jobContext.getInstanceId());
        NmHtmlExtractor extractor = new NmHtmlExtractor(path.toFile());

        getLog().info("Parsing NMs for year " + extractor.getYear() +  ", week " + extractor.getWeek());
        List<Message> messages = extractor.extractNms();

        DataFilter dataFilter = DataFilter.get()
                .fields(DataFilter.DETAILS, DataFilter.GEOMETRY, "Area.parent");

        return messages.stream()
                .map(this::extractAreas)
                .map(this::updateMessageParts)
                .map(m -> m.toVo(SystemMessageVo.class, dataFilter))
                .collect(Collectors.toList());
    }


    /**
     * Extracts areas from the message title
     * @param message the message
     * @return the update message
     */
    private Message extractAreas(Message message) {
        Area area  = null;

        // The title line/subject of the message will have a format along the lines of:
        // "Danmark. Sundet. Københavns Havn N. Stubben. Betonanlæg etableres."
        // From left to right, split the subject into potential area names and search for them in the area tree.
        String name;
        while ((name = extractPotentialAreaName(message, false, false, "da")) != null) {
            Integer parentAreaId = (area != null) ? area.getId() : null;
            Area childArea = areaService.findByName(name, "da", parentAreaId);
            if (childArea != null) {
                area = childArea;
                extractPotentialAreaName(message, true, true, "da");
            } else {
                break;
            }
        }

        if (area != null) {
            message.getAreas().add(area);
        }
        return message;
    }

    /**
     * Extracts the next potential area name from the subject of the message.
     * If the trim attribute has been set, trim the area name from the message subject
     * @param message the message
     * @param trim whether to trim the part from the message
     * @param trimOthers whether to trim the part from the message in all other languages
     * @param lang the language
     * @return the next potential area name extracted from the message subject
     */
    private String extractPotentialAreaName(Message message, boolean trim, boolean trimOthers, String lang) {
        List<MessagePart> parts = message.partsByType(MessagePartType.DETAILS);
        if (!parts.isEmpty() && parts.get(0).getDesc(lang) != null) {
            MessagePart part = parts.get(0);
            String subject = part.getDesc(lang).getSubject();
            if (subject != null && subject.indexOf('.') != -1) {
                int index = subject.indexOf('.');
                if (trim) {
                    part.getDesc(lang).setSubject(subject.substring(index + 1).trim());
                    // Trim all other language variants
                    if (trimOthers) {
                        part.getDescs().stream()
                                .map(DescEntity::getLang)
                                .filter(l -> !l.equals(lang))
                                .forEach(l -> extractPotentialAreaName(message, true, false, l));
                    }
                }
                return subject.substring(0, index).trim();
            }
        }
        return null;
    }


    /**
     * Updates the message parts of the message
     * @param message the message to update
     * @return the updated message
     */
    private Message updateMessageParts(Message message) {

        // Add a "Positions" message part if the "Details" message part has an associated geometry
        MessagePart posPart = new MessagePart(POSITIONS);
        message.partsByType(MessagePartType.DETAILS).stream()
                .filter(p -> p.getGeometry() != null && !p.getGeometry().getFeatures().isEmpty())
                .forEach(p -> Arrays.stream(app.getLanguages())
                        .forEach(lang -> {
                            MessagePartDesc desc = posPart.checkCreateDesc(lang);
                            FeatureCollectionVo geometry = p.getGeometry().toGeoJson();
                            desc.setDetails(geometryFormatService.appendGeometryToDetails(
                                    lang,
                                    desc.getDetails(),
                                    geometry));
                        }));
        if (posPart.partDefined()) {
            message.addPart(posPart);
        }

        // Sort the message parts according to the order use in legacy EfS
        List<MessagePartType> typeOrder = Arrays.asList(TIME, POSITIONS, DETAILS, PROHIBITION, SIGNALS, NOTE);
        message.getParts().sort((p1, p2) -> typeOrder.indexOf(p1.getType()) - typeOrder.indexOf(p2.getType()));

        return message;
    }

}
